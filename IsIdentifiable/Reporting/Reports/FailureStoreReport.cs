using CsvHelper;
using IsIdentifiable.Failures;
using IsIdentifiable.Options;
using IsIdentifiable.Reporting.Destinations;
using IsIdentifiable.Rules;
using System;
using System.Collections.Generic;
using System.Data;
using System.IO.Abstractions;
using System.Linq;
using System.Threading;

namespace IsIdentifiable.Reporting.Reports;

/// <summary>
/// <para>
/// <see cref="FailureReport"/> that persists all data in all <see cref="Failure"/> seen into
/// the given <see cref="IReportDestination"/> such that it can be reassembled later (persistence).
/// </para>
/// <para>This report should be used when you want to capture all output in a human readable format
/// but also be able to reload the <see cref="Failure"/> for later processing e.g. by the reviewer</para>
/// </summary>
public class FailureStoreReport : FailureReport
{
    private readonly object _odtLock = new();
    private readonly DataTable _dtAllFailures;

    private readonly int _maxSize;

    private readonly string[] _headerRow = { "Resource", "ResourcePrimaryKey", "ProblemField", "ProblemValue", "PartWords", "PartClassifications", "PartOffsets" };

    private const string Separator = "###";

    /// <summary>
    /// Creates a new report aimed at the given resource (e.g. "MR_ImageTable")
    /// </summary>
    /// <param name="targetName"></param>
    /// <param name="maxSize">Max size of the internal store before writing out to file</param>
    /// <param name="fileSystem"></param>
    public FailureStoreReport(string targetName, int maxSize, IFileSystem fileSystem)
        : base(targetName, fileSystem)
    {
        _dtAllFailures = new DataTable();

        foreach (var s in _headerRow)
            _dtAllFailures.Columns.Add(s);

        if (maxSize < 0)
            throw new ArgumentException("maxSize must be positive");

        _maxSize = maxSize;
    }

    /// <summary>
    /// Adds all destinations described in <paramref name="opts"/> to the list of output
    /// locations for this report.  Also writes the report headers to the destinations.
    /// </summary>
    /// <param name="opts"></param>
    public override void AddDestinations(IsIdentifiableOptions opts)
    {
        base.AddDestinations(opts);
        Destinations.ForEach(d => d.WriteHeader((from dc in _dtAllFailures.Columns.Cast<DataColumn>() select dc.ColumnName).ToArray()));
    }

    /// <summary>
    /// Adds a custom <paramref name="destination"/> as an output adapter for this
    /// report.  Immediately calls <see cref="IReportDestination.WriteHeader(string[])"/>
    /// with the report headers.
    /// </summary>
    /// <param name="destination"></param>
    public void AddDestination(IReportDestination destination)
    {
        Destinations.Add(destination);
        destination.WriteHeader((from dc in _dtAllFailures.Columns.Cast<DataColumn>() select dc.ColumnName).ToArray());
    }

    /// <summary>
    /// Writes the <paramref name="failure"/> to all <see cref="Destinations"/>.  The full
    /// contents of the <see cref="Failure"/> are written such that it can be reloaded
    /// later on from the outputted representation (deserialized)
    /// </summary>
    /// <param name="failure"></param>
    public override void Add(Failure failure)
    {
        lock (_odtLock)
        {
            _dtAllFailures.Rows.Add(
                failure.Resource,
                failure.ResourcePrimaryKey,
                failure.ProblemField,
                failure.ProblemValue,
                string.Join(Separator, failure.Parts.Select(p => p.Word)),
                string.Join(Separator, failure.Parts.Select(p => p.Classification)),
                string.Join(Separator, failure.Parts.Select(p => p.Offset)));

            if (_dtAllFailures.Rows.Count < _maxSize)
                return;

            CloseReportBase();
            _dtAllFailures.Clear();
        }
    }

    /// <summary>
    /// Writes the current batch of failures to all destinations.  This method
    /// is designed to be called multiple times (i.e. it is not a dispose pattern)
    /// </summary>
    protected override void CloseReportBase()
    {
        Destinations.ForEach(d => d.WriteItems(_dtAllFailures));
    }

    /// <summary>
    /// Opens a file generated by this class (when using <see cref="CsvDestination"/>) and parses
    /// the contents of the file to generate all the <see cref="Failure"/> recorded in it.
    /// </summary>
    /// <param name="oldFile">CSV file containing <see cref="Failure"/> instances serialized by this class</param>
    /// <returns></returns>
    public static IEnumerable<Failure> Deserialize(IFileInfo oldFile)
    {
        return Deserialize(oldFile, (s) => { }, CancellationToken.None);
    }

    /// <summary>
    /// Opens a file generated by this class (when using <see cref="CsvDestination"/>) and parses
    /// the contents of the file to generate all the <see cref="Failure"/> recorded in it.
    /// </summary>
    /// <param name="oldFile">CSV file containing <see cref="Failure"/> instances serialized by this class</param>
    /// <param name="loadedRows">Action to call periodically as records are read from the file (for
    /// when the file is very big and you want to show progress etc)</param>
    /// <param name="token">Cancellation token for aborting the file deserialication (and closing the file again)</param>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public static IEnumerable<Failure> Deserialize(IFileInfo oldFile, Action<int> loadedRows, CancellationToken token, IEnumerable<PartRegexRule_Temp>? partRules = null)
    {
        var lineNumber = 0;

        using var stream = oldFile.OpenRead();
        using var sr = new System.IO.StreamReader(stream);
        using var r = new CsvReader(sr, System.Globalization.CultureInfo.CurrentCulture);
        if (r.Read())
            r.ReadHeader();
        else
            yield break;
        lineNumber++;

        // "Resource", "ResourcePrimaryKey", "ProblemField", "ProblemValue", "PartWords", "PartClassifications", "PartOffsets"

        partRules ??= new List<PartRegexRule_Temp>();

        while (r.Read())
        {
            token.ThrowIfCancellationRequested();
            lineNumber++;
            var problemField = r["ProblemField"];
            var problemValue = r["ProblemValue"];
            var words = r["PartWords"].Split(Separator);
            var classes = r["PartClassifications"].Split(Separator);
            var offsets = r["PartOffsets"].Split(Separator);

            var parts = words.Select(
                (word, index) => new FailurePart(
                    word,
                    Enum.TryParse<FailureClassification>(classes[index], true, out var classification) ? classification : throw new Exception($"Invalid failure classification '{classes[index]}' on line {lineNumber}"),
                    int.TryParse(offsets[index], out var offset) ? offset : throw new Exception($"Invalid offset '{offsets[index]}' on line {lineNumber}")
                )
            );

            /* TEMP - Filter out any FailureParts covered by an PartRegexRule_Temp */
            var toRemove = new List<FailurePart>();
            foreach (var partRule in partRules)
            {
                if (!string.IsNullOrWhiteSpace(partRule.IfColumn) && !string.Equals(partRule.IfColumn, problemField, StringComparison.InvariantCultureIgnoreCase))
                    continue;

                foreach (var part in parts.Where(x => partRule.Covers(x, problemValue)))
                    toRemove.Add(part);
            }
            parts = parts.Except(toRemove);
            /* TEMP */

            if (parts.Any())
                yield return new Failure(parts)
                {
                    Resource = r["Resource"],
                    ResourcePrimaryKey = r["ResourcePrimaryKey"],
                    ProblemField = problemField,
                    ProblemValue = problemValue,
                };

            if (lineNumber % 1000 == 0)
                loadedRows(lineNumber);
        }

        loadedRows(lineNumber - 1);
    }
}
